
  % ------------------------------------------------------------------------
  % abnTeX2: Modelo de Trabalho Academico (tese de doutorado, dissertacao de
  % mestrado e trabalhos monograficos em geral) em conformidade com
  % ABNT NBR 14724:2011: Informacao e documentacao - Trabalhos academicos -
  % Apresentacao
  % ------------------------------------------------------------------------
  % ------------------------------------------------------------------------

  \documentclass[
    % -- opções da classe memoir --
    12pt,       % tamanho da fonte
    openright,      % capítulos começam em pág ímpar (insere página vazia caso preciso)
    twoside,      % para impressão em verso e anverso. Oposto a oneside
    a4paper,      % tamanho do papel.
    % -- opções da classe abntex2 --
    %chapter=TITLE,   % títulos de capítulos convertidos em letras maiúsculas
    %section=TITLE,   % títulos de seções convertidos em letras maiúsculas
    %subsection=TITLE,  % títulos de subseções convertidos em letras maiúsculas
    %subsubsection=TITLE,% títulos de subsubseções convertidos em letras maiúsculas
    % -- opções do pacote babel --
    english,      % idioma adicional para hifenização
    french,       % idioma adicional para hifenização
    spanish,      % idioma adicional para hifenização
    brazil,       % o último idioma é o principal do documento
    ]{abntex2}


  % ---
  % PACOTES
  % ---

  % ---
  % Pacotes fundamentais
  % ---
  \usepackage{cmap}       % Mapear caracteres especiais no PDF
  \usepackage{lmodern}      % Usa a fonte Latin Modern
  \usepackage[T1]{fontenc}    % Selecao de codigos de fonte.
  \usepackage[utf8]{inputenc}   % Codificacao do documento (conversão automática dos acentos)
  \usepackage{lastpage}     % Usado pela Ficha catalográfica
  \usepackage{indentfirst}    % Indenta o primeiro parágrafo de cada seção.
  \usepackage{color}        % Controle das cores
  \usepackage{graphicx}     % Inclusão de gráficos
  \usepackage{listings}     % Inclusão de código
  \usepackage{color}
  \usepackage[section]{placeins}

  \definecolor{dkgreen}{rgb}{0,0.6,0}
  \definecolor{gray}{rgb}{0.5,0.5,0.5}
  \definecolor{mauve}{rgb}{0.58,0,0.82}

  \lstset{
      frame=tb,
      language=Python,
      aboveskip=3mm,
      belowskip=3mm,
      showstringspaces=false,
      columns=flexible,
      basicstyle={\small\ttfamily},
      numbers=none,
      numberstyle=\tiny\color{gray},
      keywordstyle=\color{blue},
      commentstyle=\color{dkgreen},
      stringstyle=\color{mauve},
      breaklines=true,
      breakatwhitespace=true,
      tabsize=4
  }
  % ---

  % ---
  % Pacotes adicionais, usados apenas no âmbito do Modelo Canônico do abnteX2
  % ---
  \usepackage{lipsum}       % para geração de dummy text
  % ---

  % ---
  % Pacotes de citações
  % ---
  \usepackage[brazilian,hyperpageref]{backref}   % Paginas com as citações na bibl
  \usepackage[alf]{abntex2cite} % Citações padrão ABNT

  % ---
  % CONFIGURAÇÕES DE PACOTES
  % ---

  % ---
  % Configurações do pacote backref
  % Usado sem a opção hyperpageref de backref
  \renewcommand{\backrefpagesname}{Citado na(s) página(s):~}
  % Texto padrão antes do número das páginas
  \renewcommand{\backref}{}
  % Define os textos da citação
  \renewcommand*{\backrefalt}[4]{
    \ifcase #1 %
      Nenhuma citação no texto.%
    \or
      Citado na página #2.%
    \else
      Citado #1 vezes nas páginas #2.%
    \fi}%
  % ---


  % ---
  % Informações de dados para CAPA e FOLHA DE ROSTO
  % ---
  \titulo{Um framework para geração de testes automatizados para aplicações mobile}
  \autor{Gustavo Figueira Olegário}
  \local{Brasil}
  \data{2017}
  \orientador{Ricardo Pereira e Silva}
  \coorientador{}
  \instituicao{%
    Universidade Federal de Santa Catarina
    \par
    Centro Tecnológico - CTC
    \par
    Departamento de Informática e Estatística
    \par
    Ciências da Computação}
  \tipotrabalho{Dissertação (Bacharelado)}
  % O preambulo deve conter o tipo do trabalho, o objetivo,
  % o nome da instituição e a área de concentração
  \preambulo{Trabalho de Conclusão de Curso submetido ao Curso de
  Ciências da Computação para a obtenção do Grau de Bacharel em
  Ciências da Computação.}
  % ---


  % ---
  % Configurações de aparência do PDF final

  % alterando o aspecto da cor azul
  \definecolor{blue}{RGB}{41,5,195}

  % informações do PDF
  \makeatletter
  \hypersetup{
        %pagebackref=true,
      pdftitle={\@title},
      pdfauthor={\@author},
        pdfsubject={\imprimirpreambulo},
        pdfcreator={LaTeX with abnTeX2},
      pdfkeywords={abnt}{latex}{abntex}{abntex2}{trabalho acadêmico},
      colorlinks=true,          % false: boxed links; true: colored links
        linkcolor=blue,           % color of internal links
        citecolor=blue,           % color of links to bibliography
        filecolor=magenta,          % color of file links
      urlcolor=blue,
      bookmarksdepth=4
  }
  \makeatother
  % ---

  % ---
  % Espaçamentos entre linhas e parágrafos
  % ---

  % O tamanho do parágrafo é dado por:
  \setlength{\parindent}{1.3cm}

  % Controle do espaçamento entre um parágrafo e outro:
  \setlength{\parskip}{0.2cm}  % tente também \onelineskip

  % ---
  % compila o indice
  % ---
  \makeindex
  % ---

  % ----
  % Início do documento
  % ----
  \begin{document}

  % Retira espaço extra obsoleto entre as frases.
  \frenchspacing

  % ----------------------------------------------------------
  % ELEMENTOS PRÉ-TEXTUAIS
  % ----------------------------------------------------------
  % \pretextual

  % ---
  % Capa
  % ---
  \imprimircapa
  % ---

  % ---
  % Folha de rosto
  % (o * indica que haverá a ficha bibliográfica)
  % ---
  \imprimirfolhaderosto*
  % ---

  % ---
  % Inserir a ficha bibliografica
  % ---

  % Isto é um exemplo de Ficha Catalográfica, ou ``Dados internacionais de
  % catalogação-na-publicação''. Você pode utilizar este modelo como referência.
  % Porém, provavelmente a biblioteca da sua universidade lhe fornecerá um PDF
  % com a ficha catalográfica definitiva após a defesa do trabalho. Quando estiver
  % com o documento, salve-o como PDF no diretório do seu projeto e substitua todo
  % o conteúdo de implementação deste arquivo pelo comando abaixo:
  %
  % \begin{fichacatalografica}
  %     \includepdf{fig_ficha_catalografica.pdf}
  % \end{fichacatalografica}
  \begin{fichacatalografica}
    \vspace*{\fill}         % Posição vertical
    \hrule              % Linha horizontal
    \begin{center}          % Minipage Centralizado
    \begin{minipage}[c]{12.5cm}   % Largura

    \imprimirautor

    \hspace{0.5cm} \imprimirtitulo  / \imprimirautor. --
    \imprimirlocal, \imprimirdata-

    \hspace{0.5cm} \pageref{LastPage} p. : il. (algumas color.) ; 30 cm.\\

    \hspace{0.5cm} \imprimirorientadorRotulo~\imprimirorientador\\

    \hspace{0.5cm}
    \parbox[t]{\textwidth}{\imprimirtipotrabalho~--~\imprimirinstituicao,
    \imprimirdata.}\\

    \hspace{0.5cm}
      1. Framework.
      2. Testes.
      I. Ricardo Pereira e Silva.
      II. Universidade Federal de Santa Catarina.
      III. Bacharelado em Ciências da Computação.
      IV. Um framework para geração de testes automatizados para aplicações mobile

    \hspace{8.75cm} CDU 02:141:005.7\\

    \end{minipage}
    \end{center}
    \hrule
  \end{fichacatalografica}
  % ---

  % ---
  % Inserir errata
  % ---
  %\begin{errata}
  %Elemento opcional da \citeonline[4.2.1.2]{NBR14724:2011}. Exemplo:

  %\vspace{\onelineskip}

  %FERRIGNO, C. R. A. \textbf{Tratamento de neoplasias ósseas %apendiculares com
  %reimplantação de enxerto ósseo autólogo autoclavado associado ao %plasma
  %rico em plaquetas}: estudo crítico na cirurgia de preservação de %membro em
  %cães. 2011. 128 f. Tese (Livre-Docência) - Faculdade de Medicina %Veterinária e
  %Zootecnia, Universidade de São Paulo, São Paulo, 2011.

  %\begin{table}[htb]
  %\center
  %\footnotesize
  %\begin{tabular}{|p{1.4cm}|p{1cm}|p{3cm}|p{3cm}|}
  %  \hline
  %   \textbf{Folha} & \textbf{Linha}  & \textbf{Onde se lê}  & %\textbf{Leia-se}  \\
  %    \hline
  %   1 & 10 & auto-conclavo & autoconclavo\\
  %   \hline
  %\end{tabular}
  %\end{table}

  %\end{errata}
  % ---

  % ---
  % Inserir folha de aprovação
  % ---

  % Isto é um exemplo de Folha de aprovação, elemento obrigatório da NBR
  % 14724/2011 (seção 4.2.1.3). Você pode utilizar este modelo até a aprovação
  % do trabalho. Após isso, substitua todo o conteúdo deste arquivo por uma
  % imagem da página assinada pela banca com o comando abaixo:
  %
  % \includepdf{folhadeaprovacao_final.pdf}
  %
  \begin{folhadeaprovacao}

    \begin{center}
      {\ABNTEXchapterfont\large\imprimirautor}

      \vspace*{\fill}\vspace*{\fill}
      {\ABNTEXchapterfont\bfseries\Large\imprimirtitulo}
      \vspace*{\fill}


      \vspace*{\fill}
     \end{center}

     Este Trabalho de Conclusão de Curso foi julgado aprovado para a
     obtenção do Título de Bacharel em Ciências da Computação, e
     aprovado em sua forma final pelo Curso de Ciências da Computação
     da Universidade Federal de Santa Catarina.

     \assinatura{Dr. Prof. \textbf{\imprimirorientador} \\ Orientador}
     \assinatura{Dr. Prof. \textbf{Professor} \\ Convidado 1}
     \assinatura{Dr. Prof. \textbf{Professor} \\ Convidado 2}
     %\assinatura{\textbf{Professor} \\ Convidado 3}
     %\assinatura{\textbf{Professor} \\ Convidado 4}

     \begin{center}
      \vspace*{0.5cm}
      {\large\imprimirlocal}
      \par
      {\large\imprimirdata}
      \vspace*{1cm}
    \end{center}

  \end{folhadeaprovacao}
  % ---

  % ---
  % Dedicatória
  % ---
  \begin{dedicatoria}
     \vspace*{\fill}
     \centering
     \noindent
     \textit{ Este trabalho é dedicado a todos aqueles que jamais desistem dos seus sonhos.} \vspace*{\fill}
  \end{dedicatoria}
  % ---

  % ---
  % Agradecimentos
  % ---
  \begin{agradecimentos}
  Os agradecimentos principais são direcionados aos meus pais, irmãos,
  amigos fiéis e à minha namorada, que sempre acreditaram em meu potencial
  e que me ajudaram, de alguma forma, a concluir minha graduação.

  Agradeço também ao professor Ricardo por seu tempo e dedicação neste trabalho e que desde o início esteve disposto a ajudar na orientação.

  Por último, mas não menos importante, agradeço a Deus por esta oportunidade. Pois, sem Sua graça, nada disso existiria.

  \end{agradecimentos}
  % ---

  % ---
  % Epígrafe
  % ---
  \begin{epigrafe}
      \vspace*{\fill}
    \begin{flushright}
      \textit{Não se trata de bater duro. Se trata \\
       de quanto você aguenta apanhar e seguir em \\
       frente. O quanto você é capaz de continuar \\
       tentando. É assim que se consegue vencer.}
    \end{flushright}
  \end{epigrafe}
  % ---

  % ---
  % RESUMOS
  % ---

  % resumo em português
  \begin{resumo}
    No escopo da engenharia de software, durante o processo de desenvolvimento
    de aplicações, sabe-se que as fases de desenvolvimento e testes são as que,
    costumeiramente, demandam muito esforço. Desta forma, uma ferramenta capaz
    de gerar testes automatizados para certas aplicações, no mundo de
    dispositivos mobile, pode ser vista como uma forma de acelerar o processo de
    desenvolvimento e permitir que os desenvolvedores se concentrem em
    atividades que demandem mais inteligência do que trabalho manual. Nesse
    sentido, a proposta desse trabalho é desenvolver um framework orientado
    a objetos capaz de apoiar tal atividade no contexto dos dispositvos móveis
    que possuem o sistema operacional Android. A finalidade do framework é diminuir
    o esforço e tempo investidos durante a fase de testes automatizados.

   \vspace{\onelineskip}

   \noindent
   \textbf{Palavras-chaves}: Engenharia de Software. testes. aplicações mobile.
   framework OO
  \end{resumo}

  % resumo em inglês
  \begin{resumo}[Abstract]
   \begin{otherlanguage*}{english}
     In the software engineering scope, through the development process of
     applications, the stages of development and tests, usually, are the
     ones that require more effort. Therefore, a tool capable to generate
     automated tests for certain applications, at the context of mobile
     phones, can be seen as an accelerator during the process of
     tests allowing the developers to focus on tasks that demands
     more intelligence than handwork. So, the main objective of this work
     is to develop a framework capble to support this task in mobile
     gadgets context that runs Android. The framework aims to decrease the amount of
     time and efforts invested during the period of development of automated tests.

     \vspace{\onelineskip}

     \noindent
     \textbf{Key-words}: Software Engineering. tests. mobile application. framework OO
   \end{otherlanguage*}
  \end{resumo}
  % ---

  % ---
  % inserir lista de ilustrações
  % ---
  \pdfbookmark[0]{\listfigurename}{lof}
  \listoffigures*
  \cleardoublepage
  % ---

  % ---
  % inserir lista de tabelas
  % ---
  \pdfbookmark[0]{\listtablename}{lot}
  \listoftables*
  \cleardoublepage
  % ---

  % ---
  % inserir lista de abreviaturas e siglas
  % ---
  \begin{siglas}
    %\item[Fig.] Area of the $i^{th}$ component
    \item[FraG] *A CONFIRMAR*
    \item[XP] Extreming Programming
    \item[TDD] Test Development Driven
    \item[DRY] Don't Repeat Yourself
    \item[AFD] Autômato Finito Determínistico
    %\item[123] Isto é outro número
    %\item[lauro cesar] este é o meu nome
  \end{siglas}
  % ---

  % ---
  % inserir o sumario
  % ---
  \pdfbookmark[0]{\contentsname}{toc}
  \tableofcontents*
  \cleardoublepage
  % ---



  % ----------------------------------------------------------
  % ELEMENTOS TEXTUAIS
  % ----------------------------------------------------------
  \textual


  % ----------------------------------------------------------
  % PARTE - preparação da pesquisa
  % ----------------------------------------------------------
  \chapter{Introdução e objetivos}
  \section{Introdução}
      Desde o tempo em que o homem começou a programação de computadores, a atividade
  de teste de software sempre foi uma atividade vista com descaso e que só era
  executada se sobrasse tempo durante o projeto. Em alguns casos ela costumava ser
  usada como castigo para programadores que não cumpriam com suas funções
  (WAZLAWICK, 2012).

  Com a chegada da crise do software (DIJKSTRA, 1971), não demorou muito tempo
  para que desenvolvedores percebessem que a atividade de criação e execução de
  testes era uma atividade extramemente importante e que também deveria ser
  incluída durante o planejamento do projeto.

  Nos dias atuais, os testes são tão importantes que eles são incorporados
  por praticamente todas as metodologias ágeis, as quais, por sua vez,
  são as mais adotadas no mercado atualmetne (JEREMIAH, 2017). A relevância dessa fase
  no proesso de desenvolvimento é tão grande que dependo da metodologia
  adotada, o programador deve primeiro programar o teste e depois o módulo
  o qual lhe foi designado.

  Entretanto, devido a essa notória importância que a fase de testes ganhou nos
  últimos tempos, ela também tem sido uma das partes que mais tem tomado tempo
  em projetos(ERIKSSON, 2014) e que poderia ser facilmente automatizada em muitas partes já que
  costuma ser uma atividade que demanda mais trabalho manual do que inteligência.
  Nesse cenário, a proposta desse trabalho é desenvolver uma ferramenta para
  geração de testes automatizados para determinadas aplicações mobile, a fim de
  que os desenvolvedores possam se focar em outras tarefas enquanto
  que o Framework se encarrega de gerar os testes por conta própria.

  Sendo assim, nas próximas partes desse trabalho é, primeiro, apresentado de maneira
  mais precisa o framework. Em seguida, é feito um estudo de técnicas de testes
  de software e quais as ferramentas disponíveis atualmente no mercado. Por último, a
  proposta de desenvolvimento do framework e uma apresentação de suas capacidades.

  \section{Justificativa}
      Como dito previamente na introdução, a fase que mais toma tempo durante
      um projeto de desenvolvimento de software é a parte de testes. Muitos
      projetos poderiam ter seu tempo reduzido ou incluir mais requisitos
      implementados por entrega, se os desenvolvedores pudessem investir mais
      tempo nisso ao invés de investirem esforços em desenvolvimento de testes.
      Sendo assim, este trabalho se propõe em implementar um framework capaz de
      suportar a produção de testes de maneira automática, a fim de que os
      programadores possam focar naquilo que realmente importa: suas aplicações.


  \section{Objetivos geral}
      Analisar e desenvolver um framework orientado a objetos capaz de suportar a produção
      de testes automatizados para aplicações específicas de dispositivos que possuam como
      sistema operacional o Android.

  \section{Objetivos específicos}
  \begin{enumerate}
      \item Diminuir tempo e esforço investidos durante a fase de testes de um projeto de software
            de determinadas aplicações Android.
      \item Desenvolver uma ferramenta gratuita que permita desenvolvedores Android focarem
            em tarefas que demandem mais inteligência do que trabalho braçal.
  \end{enumerate}

  \section{Estrutura do documento}
      Esta secção inicial aborda a justificativa do trabalho, bem como seus
      objetivos gerais e específicos. Na secção 2, são apresentados os
      conceitos relevantes ao trabalho para melhor compreensão do leitor.
      A secção 3 apresentará trabalhos relacionados. Em seguida,
      na secção 4 é mostrado como o framework foi implementado e, por
      último, a secção 5 mostra-se os resultados obtidos juntamente com
      sugestões de trabalhos futuros.
  % ----------------------------------------------------------
  % Capitulo com exemplos de comandos inseridos de arquivo externo
  % ----------------------------------------------------------

  \include{abntex2-modelo-include-comandos}

  % ----------------------------------------------------------
  % Parte de revisãod e literatura
  % ----------------------------------------------------------
  \part{Fundamentação teórica}

  % ---
  % Capitulo de revisão de literatura
  % ---
  \chapter{Frameworks}

      Como este trabalho se propõe a implementar um framework de geração
      automática de testes é importante que este conceito esteja muito bem
      definido. No mundo da programação, os desenvolvedores estão
      acostumados a usar bibliotecas ou código de terceiros. Esse processo
      geralmente resume-se, basicamente, a executar um comando de inclusão
      de arquivo e as funções previamente implementadas já podem ser usadas.

      O uso de bibliotecas é algo que geralmente traz melhoras significativas
      para o código que está sendo desenvolvido, visto que o programador
      está fazendo reuso de um módulos que já foram usados no passado e,
      consequentemente, está menos a suscetível a sofrer com defeitos. Além
      disso, algumas bibliotecas estão constantemente recebendo atualizações
      a fim de fornercer novas facilidades ao programador, bem como minimizar
      o número de defeitos presente.

      Entrento, o conceito de framework em si, vai muito além do que uma
      simples coleção de funções que podem ser reusadas entre vários
      projetos. O framework vai ser
      responsável por orientar o programador de como ele deve desenvolver
      o projeto, ou pelo menos uma parte dele. O framework geralmente
      indica ao programdor aonde o código deve ser produzido e de que forma.

      Esse estilo de programação não só fornece uma estrutura mais sólida
      ao projeto, pois todos os programadores da equipe devem seguir o mesmo
      padrão, como também segue a mesma filosofia das bibliotecas em que o
      foco principal é o reuso de código entre projetos que compartilham
      o mesmo domínio de problema, ou que seja muito similar.

      Nas próximas subseções será apresentado como foi o surgimento inicial
      do conceito de framework, quais os principais pontos positivos e
      negativos de se usar uma ferramenta como essa e as princípios
      seguidas por frameworks.

      \section{Origem dos Frameworks}
          Sabe-se que nos primórdios a indústria de software tinha como principal
          foco de atuação quase que única e exclusivamente a resolução de problemas
          matemáticos. Com o passar dos anos, as linguagens de programação
          foram ficando mais robustas e o hardware também foi se desenvolvendo. Esse
          processo, permitiu que computadores se popularizassem e eis que a necessidade
          por novos softwares foi surgindo.

          Entretanto, os softwares que estavam, e continuam, sendo exigidos pelo
          mercado eram aplicativos com complexidade cada vez maior. Não bastasse isso,
          as datas de planejamento de projeto começaram a ficar ainda mais apertadas
          para poder suprir a necessidade de seus clientes. Esse cenário dantesco
          que começou a se formar para os progamadores, começou a levar os desenvolvedores
          a filosofar sobre qual seria a melhor forma de resolver tal situação.

          Analisando diferentes projetos, ficou evidente para muitos programadores
          que eles estavam sofrendo com o mal de estar o tempo todo "reiventando
          a roda". Em outras palavras, em diferentes projetos sempre se estava
          reimplementando o mesmo módulo ou um muito similar. Dessa forma, ficou
          claro que não havia necessidade de sempre estar se desenvolvendo um mesmo
          componente para diferentes projetos, bastava que se tirasse proveito do reuso
          que o problema estaria resolvido.

          É claro que esse processo de reuso de diferentes partes de um software,
          em termos de granularidade, foi aumento aos poucos através dos tempos.
          Inicialmente começou-se com funções básicas como na linguagem C, por exemplo,
          foi avançando para estruturas mais complexas como classes até que chegou
          no que conhecemos por frameworks nos dias de hoje.

          Um framework é, então, nada mais que um conjunto bem estruturado de classes
          relaciodas através de associações e heranças. Porém esse conjunto ele não
          é totalmente finalizado, algumas partes ficam não terminadas, propositalmente,
          para poder dar uma certa de liberdade de domínio de problema. Ou seja, nada
          andiantaria o framework ser totalmetne implementado por ele próprio, pois
          aí ele não daria uma certa flexibilidade para o usuário e o único problema
          que ele resolveria seria o que ele mesmo implementa.

          No framework FraG, um framework voltado a suportar o desenvolvimento de
          programas de jogos de tabuleiro (SILVA, 1998), podemos ver um exemplo disso. Existe
          a classe Board, que representa o tabuleiro de um jogo. Porém, um
          tabuleiro, como sabemos, pode variar muito de jogo para jogo. Dessa
          forma deixam-se alguns métodos abstratos e o usuário apenas estende
          essa classe para seu domínio de aplicação e implementa os métodos que
          necessita e adiciona os atributos que forem necessários, mantendo
          um código organizado e seguindo boas práticas de orientação a objetos.

          \begin{figure}[htbp]
              \begin{center}
                  \includegraphics[width=1.0\textwidth]{img/frag.png}
              \end{center}
              \caption{\label{fig:passaro}Modelagem do framework FraG.}
          \end{figure}

          Dessa forma, o desenvolvedor apenas precisou desenvolver algumas pequenas
          partes para ter uma aplicação totalmente pronta, tendo a maior parte
          do software implementado pelo framework.

          A implementação de um framework consiste principalmente em identificar
          qual domínio de problema ele deve dar suporte. FraG, fica evidente que
          era um framework voltado a
          desenvolvimento de jogos de tabuleiro. O processo de modelagem
          requer que o desenvolvedor identifique as classes mais comuns de um domínio
          problema, também conhecidos como "hot spots". Esse processo costuma ser
          não trivial, pois o responsável pela modelagem do framework deve estudar
          ao menos 3 aplicações que compartilham o mesmo domínio (JOHNSON, 1993),
          porém sem se prender muito aos detalhes do problema específico que está
          sendo resolvido.

          Após identificadas as classes que semanticamente são mais utilizadas em um
          certo domínio, inicia-se o processo de modelagem que
          que deve-se definir quais classes deverão ser implementadas e quais serão
          redifinidas pelo desenvolvedor. A partir daí, consegue-se obter resultados
          de quão eficiente o framework desenvolvido é. Para analisar esse dado
          basta verificar em um projeto que utiliza o framework verificar a porcentagem
          de classes implementadas do zero e quais foram reaproveitadas do framework.
          Isso é claro desconsiderando classes como de interface com o usuário, por
          exemplo, visto que usualmente são totalmente dependendes do domínio da aplicação.

      \section{Aspectos postivos e negativos}
          Quando um framework é utilizado em um projeto de software, é importante estar
          atento ao que se ganha e ao que se perde em termos de implementação. Quando
          um projeto é feito "from scratch", ou seja, todas as classes são
          produzidas do zero pelo próprio time de desenvolvimento, os programadores tem
          total liberdade para implementar as classes como julgarem melhor. Contudo, o
          problema disso, obviamente, é que nada é reusado, a aplicação fica muito
          suscetível a defeitos e demanda muito esforço.

          \begin{figure}[htbp]
              \begin{center}
                  \includegraphics[width=1.0\textwidth]{img/scratch.png}
              \end{center}
              \caption{\label{fig:passaro}Um exemplo de aplicação \textit{from scratch}}
          \end{figure}

          Quando um framework é utilizado para suprir as necessidades um projeto, muitas
          das classes que inicialmente seriam implementadas do zero, já estão praticamente
          prontas, necessitando, geralmente, apenas de poucas sobrescritas de métodos.
          Os ganhos nesse processo é que os desenvolvedores têm seus esforços
          minimizados, uma vez que boa parte das classes já estão totalmente implementadas.
          Outro aspecto positivo ao se utilizar um framework é que a granularidade do
          reuso é muito maior do que se comparada a um projeto em que não se use frameworks.
          Em outras palavras, ao utilizar-se um framework dentro de uma aplicação o reuso
          costuma atingir facilmente dezenas de classes. Entretanto, se o mesmo projeto
          fosse implementado pelo time de desenvolvimento, a partir da busca de classes
          reusáveis provavelmente o número de classes reusadas seria bem menor.

          Quanto aos aspectos negativos, o mais fácil de ser observado é que os
          desenvolvedores da aplicação ficam presos à arquitetura e ao controle
          de fluxo de dados impostos pelo framework. Isso decorre do fato de que, como a
          maioria das classes do domínio do problema já estão sendo implementadas pelo
          framework, a arquitetura, juntamente com o fluxo de controle, já sao, por
          definição pré-estabelecidas.

          Outro ponto negativo é que os programadores precisam ter um bom conhecimento
          de como funciona o framework para poder utilizá-lo corretamente. É necessário
          ter conhecimento de como o framework é implementado para saber quais classes
          já foram programadas e acabar não duplicando uma funcionalidade já existente.
          O problema é que para conseguir tais informações os desenvolvedores terão que
          conferir a documentação disponível ou o código fonte. A primeira alternativa,
          apesar de ser a melhor, nem sempre é viável, pois nem sempre é produzida ao
          final de um projeto. Existem casos em que mesmo a documentação não é capaz
          de detalhar o que foi implementado, seja pela não completude ou por não ter
          sido atualizada durante o desenvolvimento do projeto.

          Já a alternativa de analisar o código fonte é, de longe, a maneira mais árdua
          de aprender como a ferramenta funciona. Exige do programador uma atividade
          de engenharia reversa e costuma ter um baixo rendimento. Em alguns cenários
          pode até mesmo deixar o desenvolvedor mais confuso ainda. Isso é claro
          considerando um framework de código aberto, do contrário nem mesmo acesso
          ao fonte o desenvolvedor teria.

      \section{Princípios de frameworks}
          Nessa secção são apresentados alguns conceitos implementados pela maioria
          dos frameworks, mas isso não siginifica que caso algum framework não implemente
          alguma dessas ideias ele não possa ser classificado como tal. Voltando mais uma
          vez ao exemplo do framework do FraG, fica evidente que os frameworks se baseiam
          fortemente nas caracrísticas de associações e heranças.

          É fácil de compreender o motivo pelo qual a herança é tão usada no universo de
          frameworks. Quando utilizada em classes abstratas, por definição, é exigido que
          o programador implemente os métodos abstratos definidos pela superclasse. Isso
          garante que sempre que qualquer objeto que herde a classe abstrata, no momento
          que for utilizado interna ou externamente pelo framework, os métodos estarão
          implementados, o que possibilita uma certa customização dentro do framework e
          é aí que vem a flexibilidade dos frameworks dentro de um domínio de problema.

          Tal fato fica evidente quando observa-se a modelagem do par \textit{Template} e
          \textit{Hook}. Nesse modelo, o método \textit{Template} é um algoritmo sempre
          estável que inicializa objetos que sempre serão necessários para o framework.
          Entretanto, como existem objetos que podem variar de aplicação para aplicação
          ao final da execução do método \textit{Template} o método \textit{Hook} é
          executado. Esse, por sua vez, é um método que deve ser sobrescrito pelo usuário
          para que ele possa inicialzar demais objetos que necessite para sua aplicação
          relacionados ao framework.

          \begin{figure}[htbp]
              \begin{center}
                  \includegraphics[width=1.0\textwidth]{img/templateHook.png}
              \end{center}
              \caption{\label{fig:passaro}Modelagem dos métodos Template e Hook}
          \end{figure}

          Outro fato que leva a relação de herança ser tão explorada no mundo de frameworks,
          é o que se chama de princípio de Hollwood (\textit{"Don't call us, we'll call you"}).
          Esse princípio decorre do fato de que quando o desenvolvedor estiver usando a
          ferramenta ele não deve instanciar objetos do framework e chamar métodos. Pelo
          contrário, ele deve criar novas classes que herdem de outras já definidas pelo
          framework. Usualmente, são classes abstratas. Dessa forma, quando a aplicação
          estiver sendo executada, o framework saberá quais classes foram herdadas e
          quais métodos foram escritos. Dessa forma, ele se encarrega de chamar
          os objetos executando corretamente os novos métodos sobrescritos. Daí
          vem o lema: \textit{"Don't call us, we'll call you"}.

          Já o fato de existir tantas relações de associações no framework, vem
          do fato de que os \textit{Design Patterns} são amplamente neste universo de
          soluções. \textit{Design Patterns} são modelagem para problemas extremamente
          elegantes e que solucionam problemas que já estão muito bem conhecidos na
          modelagem de software. Na modelagem do FraG, podemos perceber em que há
          casos em que está sendo usado até 3 \textit{Design Patterns} em paralelo:
          \textit{factory, composite, decorator}. Não cabe aqui nesse escopo explanar
          cada um desses \textit{Design Patterns}, muito menos todos os existentes,
          mas é importante deixar claro que cada framework, muito provavelmente, terá
          padrões implementados conforme a necessidade.

          Outro ponto muito forte, é que o framework deve ser capaz de dar suporte a
          uma grande quantidade de aplicações com o mesmo domínio que ele. Como foi
          visto, esse processo na modelagem do framework vem do fato de várias
          aplicações que compartilham o mesmo domínio terem sido exaustivamente
          estudas e terem seus módulos semelhantes identificados e implementados
          de forma genérica na nova ferramenta. Feita essa parte, basta que
          os desenvolvedores escolham precisamente quais classes devem ser reescritas
          em cada projeto, e terão boa parte da implementação já realizada e testada
          com uma quantidade linhas de código infinitamente menor comparado se
          tivessem que realizar o mesmo projeto sem o auxílio do framework

  % ---
  \chapter{Testes}
  % ---
      Nos primórdios da história do desenvolvimento de software, a etapa de testes
      era geralmente um parte vista com maus olhos pelos programadores e rotineiramente
      só se realizava quando "sobrava tempo" no projeto. Com o passar do tempo, foi
      ficando evidente para as empresas que a parte de testes é essencial para
      assegurar a qualidade do produto (WAZLAWICK, 2012). Ela não só é importante
      para comprovar o correto funcionamento, como também ajuda a garantir
      estabilidade durante a refatoração de código, pois se um teste estava obtendo
      sucesso antes da alteração e passou apresentar falhas depois das mudanças é
      porque certamente houve algum equívoco por parte de quem alterou o código.

      Nessa parte do trabalho é de suma importância deixar esclarecido
      que um projeto que foi conduzido sem testes, pode atigingir um patamar
      satifatório de qualidade ao longo do processo, mas isso provavelmente terá um
      custo alto, uma vez que a probilidade de se detectar uma grande quantidade
      de defeitos é alto. Sendo assim, o time de desenvolvimento terá que gastar
      mais tempo arrumando falhas que poderiam ter sido percebidas mais cedo.
      Isso faz com que o tempo de projeto aumente bem como os custos. Dessa forma
      é sempre importante que a parte de testes esteja prevista no planejamento
      inicial de um projeto de software.

      É importante deixar claro, também, desde já, que o teste de software em momento
      algum supõe que o módulo implementado esteja livre de defeitos. A única coisa que o
      teste garante para o desenvolvedor é que para as entradas especificadas o
      componente está se comportando como o programador desejava. O teste costuma
      ser implementado pensando em como fazer com que o módulo dê problemas, mas
      também não esquecendo da \textit{happy path}, também conhecido como sequência
      de estados em que não há ações inválidas. O teste é, então, nada mais que um conjunto
      de código que coloca o módulo que está sendo testado em um determinado estado,
      ou seja com valores específicos para as variáveis e analisa como o módulo está
      reagindo.

      Pensando em um cenário mais prático, propõe-se um módulo simples em que a única
      responsabilidade é verificar se um dado CPF é válido ou não, mesmo que possua uma
      máscara. Abaixo, podem-se observar as assinaturas de método do mesmo na linguagem
      \textit{Python}.

      \begin{figure}[htpb]
          \begin{lstlisting}
              class CpfValidator(object):
                def __init__(self):
                  # TODO
                  pass

                def cpf_is_valid(cpf):
                  # TODO
                  pass

                def cpf_with_mask_is_valid(cpf_with_mask):
                  # TODO
                  pass
          \end{lstlisting}
          \caption{\label{fig:passaro}Módulo com assinaturas de método para validar CPF}\vspace{-1.2\baselineskip}
          \centering
      \end{figure}

      Apesar de nenhum dos métodos ter sido realmente implementado, é perfeitamente
      possível desenvolver um arquivo de teste para esse módulo. Basta que o programador
      tenha conhecimento do algoritmo de validação de CPF. Dessa forma, ele saberá quando
      um CPF é válido mesmo estando sem a máscara (i.e. formatação). Ou seja, quando
      o teste for implementado basta ele escrever que os CPFs que obedeçam o algoritmo
      devam ser classificados como válidos, enquanto que os que não são validados pelo
      algoritmo devem ser rejeitados. Com o teste desenvolvido, basta ele executá-lo e
      obviamente o teste retornará mensagem de erro, isso porque o módulo ainda não
      foi implementado. Caso o teste retorne somente mensagens de sucesso é porque o
      teste possui algum equívoco.

      Com o teste produzido, o progamador dever seguir aquilo que é conhecido como
      \textit{baby steps}. O teste, uma vez escrito e executado, dirá qual o erro
      que está acontecendo, seja função não implementada, método retornando valores
      incorretos, objeto nulo. Dessa forma, o desenvolvedor irá corrigir o erro e
      irá executar novamente. Provalvelmente na segunda iteração, o teste apontará
      um novo erro. O programador deve, então, proseguir nesse processo até que o
      teste retorne somente mensagens de sucesso.

      Esse processo é também conhecido como TDD. O diagrama seguinte ilustra bem esse
      processo e tamanhobém é conhecido como \textit{red, green and refactor}, já que o
      programdor começa inicialmente na fase de erros (\textit{red}), faz somente o
      necessário para que o módulo passe no teste (\textit{green}) e melhora no final
      a qualidade do código a medida do necessário (\textit{refactor}) (BECK, 2004).

      \begin{figure}[htbp]
          \begin{center}
              \includegraphics[width=0.4\textwidth]{img/rgf.png}
          \end{center}
          \caption{\label{fig:passaro}Diagrama que representa o padrão RGF}
      \end{figure}

      Ainda no contexto de desenvolvimento de testes, é importante que os desenvolvedores
      e o time de qualidade estejam constantemente refatorando o código produzido por
      cada um. Isso é importante, pois quem está desenvolvendo o módulo já sabe como
      o código funciona e fica mais difícil em perceber o local do defeito. Entretanto,
      quando alguém que não desenvolveu o componente começa a se familarizar mais com o código
      ela vai, usualmente, ler cada linha do código e tentar enteder a semântica de cada
      uma delas. Dessa forma, ficará muito mais evidente para quem está de fora identificar
      o erro. Por isso, os cenários de teste devem ser sempre atualizados e refatorados
      (REID, 2016).

      Outro ponto importante a ser ressaltado é a questão das \textit{pré e pós condições} de
      um dado caso de teste. A pré-condição é uma obrigatoriedade que deve ocorrer
      antes que um dado método inicialize. Pensando num exemplo mais prático,
      imagina-se uma outra classe que executa algum procedimento depois de a classe
      de validaçao de CPF ter comprovado que o dado informado está correto. Nos métodos
      que essa nova classe implementa, o desenvolvedor não precisa se preocupar se o
      dado está correto ou não, pois a classe anterior já o fez. Isso é o que se chama
      de pré-condição. Já a pós-condição é o estado que o sistema deve se encontrar
      após o procedimento ter sido executado. Muitas vezes, o teste deve verificar
      se o sistema chegou no estado esperado. No mesmo exemplo, supõe-se que a nova
      classe pesquise no banco o usuário pelo CPF e mande um email para o mesmo. Para
      ver se a pós-condição foi atendida, o sistema deve verificar se o usuário recebeu
      o email.

      Nos dias atuais, o mercado é repleto de ferramentas e frameworks capazes de
      auxiliar os desenvolvedor durante a implementação de testes, fornecendo
      objetos falsos, também conhecidos como \textit{mocks}, funções de asserção,
      execução de testes em ordem aleatória. Como o intuito de trabalho é desenvolver
      um framework que seja capaz de automatizar a produção de testes, esse capítulo
      tratará essencialmente de tipos de teste, níveis e técnicas de teste. Neste trabalho,
      testes relacionados a segurança e desempenho, como de carga e stress, não serão
      contemplados, pois fogem do escopo do que o trabalho se propõe a fazer.

      \section{Modelagem e implementação de testes}
          A modelagem de testes é uma fase importante, visto que é responsável
          por garantir o mínimo de qualidade no módulo que está sendo implementado.
          O desenvolvimento de uma aplicação pode seguir a filosofia TDD em que o
          programador primeiro implementa o teste e depois desenvolva o módulo que
          lhe foi designado. Porém, nada impede que o desenvolvedor implemente
          inicialmente o módulo e depois avançe para a parte de teste.

          Entretanto, durante a modelagem de testes, o mínimo que o desenvolvedor precisa
          conhecer para poder implementar o teste são os métodos do artefeato que
          lhe foi atribuido, bem como a ideia de seus algoritmos. Dessa forma ele
          consegue separar as entradas para o teste em dois grandes conjuntos: o
          conjunto das entradas válidas e das inválidas. De posse de tais informações
          básicas, ele pode escrever testes que seguem o \textit{happy path} e aqueles
          que devem lançar algum tipo de exceção.

          Para deixar mais claro, voltemos ao exemplo do módulo de validação de CPF
          escrito em \textit{Python}. Como pode-se perceber pelo código fornecido na
          Figura 4, é facilmente perceptível que a linguagem é \textbf{fracamente tipada},
          ou seja, é deixado ao interpretador inferir a tipagem de cada variável. Para
          efeitos práticos, será considerado que os parâmetros fornecidos para os dois
          métodos de validação sejam do tipo \textit{string}. Um possível cenário de teste
          que segue o \textit{happy path} seria fornecer um CPF válido e o teste iria
          retornar dizendo que tudo ocorreu como esperado. Por outro lado, se em algum
          cenário de teste em que seja fornecida uma sequência de inteiros, o correto
          seria que o módulo lançasse alguma exeção do tipo \textit{InvalidFormat} e o
          teste detectasse que essa exeção foi lançada. Ao perceber que houve uma exceção
          o teste deve informar, novamente, tudo ocorreu como esperado. Do contrário, ele
          deve trazer um relatório escrito dizendo que estava sendo esperado uame exceção,
          porém ela não ocorreu.

          Na modelagem de testes é importante também que durante a implementação exista
          o teste de entradas aleatórias para simular uma possível simulação com o usuário.
          Nos dias atuais, existem várias bibliotecas capazes de gerar dados falsos que
          cumprem com este objetivo e são capazes de criar informações falsas, porém válidas,
          como: nomes, emails, senhas, cartões de crédito, CPF. Sendo assim, é importante
          também que durante a modelagem de teste o desenvolvedor preveja ao menos um cenário
          em que ele possa tirar proveito dessas bibliotecas.

          A modelagem de teste em si pode ser abordada de inúmeras formas. Dentro da ciência
          da computação, o mais comum é enxergar o teste do módulo como sendo um \textbf{
          autômato finito}. Os estados representam o objeto em si e as transições
          seriam os métodos e os possíveis valores de retorno, ou execções, dependendo dos
          valores passados para o método. O objetivo do teste, vendo a modelagem por essa
          ótica, seria  verificar se a máquina chegou num estado de transição, ou não.
          Nesse sentido, podemos ver um autômato representando o teste para a validação de
          um CPF no módulo representado anteriormente.

          \begin{figure}[!htb]
              \begin{center}
                  \includegraphics[width=0.80\textwidth]{img/afd.png}
              \end{center}
              \caption{\label{fig:passaro}Diagrama que representa o teste do módulo de CPF na ótica de AFD}
          \end{figure}

          Olhando para o autômato descrito na Figura 6, o desenvolvedor se quisesse garantir
          o máximo de qualidade possível, teria que testar todos os caminhos possíveis
          partindo do estado inicial. Nesse exemplo, a tarefa de testar o módulo é perfeitamente
          realizável, uma vez que existem poucas transições. Porém, pensando em casos mais
          reais em que os módulos possuem pelo menos de 6 a 8 procedimentos e que podem ter
          suas próprias execeções, a tarefa de testar completamente um artefato começa a ficar
          inviável. Nesse sentido, o programador deve priorizar as entradas mais comuns
          e algumas exóticas para garantir uma certa qualidade.

          Ainda dentro do contexto do autômato, é importante lembrar que não foram representadas
          mais transições dos estados mais à direita em direção a outros estados por uma mera
          questão de legibilidade. Entretanto, dentro de um contexto de um objeto que é utilizado
          várias vezes, a chamada repetitiva de vários métodos sucessivamente pode acarretar,
          eventualmente, na mudança de algum atributo que poderia encadear alguma mudança no
          comportamente do método, dependendo do algoritmo implementado. Sendo assim, é importante
          que o programador tenha em mente essas possibilidades também.

          Já no que se refere à parte de implementação, a implementação do padrão de projeto
          \textit{factory} (FOWLER, 2003) costuma ser muito comum, já que é uma solução necessária e elegante
          para os testes. Esse padrão se faz essencial para manter um código mais limpo, visto
          que em cada cenário de teste o desenvolvedor precisará de objetos com valores de
          atributos diferentes. Dessa forma, ele pode usar uma biblioteca que implemente a
          o padrão para os objetos necessários para o teste e para cada cenário ele pede
          objetos diferentes para a fábrica. Isso ajuda a manter um código mais legível, visto
          que se esse padrão não fosse utilizado, para cada teste o programador teria que sempre
          estar instanciando um objeto da mesma classe e configurando os valores manualmente,
          o que não é nada DRY.

      \section{Níveis de teste}
          Dentro do universo de teste de software, pode-se classificar os testes pelos seus
          níveis ou fases. A classificação decorre do fato de que a medida que a aplicação
          vai crescendo os testes também precisam ter uma complexidade maior pois o número
          de possibilidades vai aumentando e precisam sempre as mais prováveis açoes do
          usuário. Classicamente (WAZLAWICK, 2012), os testes, quando dividos dessa forma,
          podem pertencer alguma dessas classes: unidade, integração, sistema, aceitação e
          o de regressão. Nas próximas subsecções seram apresentados previamente cada uma
          dessas classificações.

          \subsection{Teste de unidade}
              O teste de unidade é o teste mais básico de um software. O intuito dele é basicamente
              testar a classe que está para ser implementada ou que recém foi programada. Boa
              parte dos testes de uma aplicação são classificados dessa forma, uma vez que são
              os mais baratos de serem desenvolvidos e os mais rápidos de serem executados (FOWLER, 2012).
              Isso é também conhecido como \textit{pirâmide de testes}. Este nível de teste visa somente
              fazer o teste de uma classe isolada. Caso a classe que está sendo testada iteraja
              de alguma forma com outras classes, seja por atributos ou parâmetros de funções,
              o programador, deve, então, usar objetos falsos, também conhecidos como \textit{mock},
              para simular a classe que possui relação com a classe que está sendo testada.
              Essa metodologia garante que caso qualquer defeito detectado pelo teste, o defeito
              vem única e exclusivamente da classe que está sendo testada, e não de classes terceiras.

              \begin{figure}[!htb]
                  \begin{center}
                      \includegraphics[width=0.55\textwidth]{img/pyramid.jpg}
                  \end{center}
                  \caption{\label{fig:passaro}Pirâmide que correlaciona quantidade de cada nível de teste}
              \end{figure}

          \subsection{Teste de integração}
              Como o nome já sugere, o objetivo desse teste é garantir a qualidade de dois módulos
              que trabalham em conjunto. Nesse nível deve-se testar todas os módulos que possuêm
              alguma relação do tipo: associação, composição ou agregação. Ao invés de usar objetos
              falsos, como era feito no nível anterior, usam-se objetos verdadeiros e testam-se os
              métodos pelos quais estes objetos trocam mensagens. Em casos em que um dos módulos
              estava funcionando no teste de unidade e passou a não funcionar no teste de integração,
              é porque muito provalmente o módulo que foi integrado está com algum problema. Este tipo
              de teste não deve cobrir integrações com interfaces ou integração com sisteamas de
              terceiros, APIs por exemplo.

          \subsection{Teste de sistema}
              O teste de sistema é o teste em que os desenvolvedores utilizam o sistema no modo de
              produção fingindo ser um usuário comum e simulando suas respectivas ações. Esse teste,
              geralmente usa como base algum caso de uso descrito no processo de engenharia de
              requisitos e também busca achar eventuais defeitos na interface com o usuário. Esse
              teste atualmente pode ser facilmente automatizado, mas como a interface é um componente
              que usulamente está sendo alterado algumas empresas ainda preferem realizá-lo de maneira
              manual e automatizar somente quando a interface já está bem estabelecida.

          \subsection{Teste de aceitação}
              O teste aceitação é o teste mais importante de todos, pois é nesse teste em que o
              usuário utiliza o sistema sem auxílio dos desenvolvedores. Ele é o mais importante,
              pois o cliente dirá se as funcionalidades requisitadas foram cumpridas e valida
              se a coleta de requisitos foi feito da forma correta.

          \subsection{Teste de regressão}
              O teste de regressão é um caso. Esse nível de teste busca executar toda a base de
              testes para um sistema que foi recém refatorado ou que teve uma nova versão lançada.
              O nome vem do fato de que caso o sistema que foi atualizado estava sendo aprovado
              nos testes e passou a ter erros, é dito, então, que o sistema regrediu.

      \section{Técnicas de teste}
          As técnicas de teste dizem respeito a forma como os casos de teste serão implementados.
          Todas elas possuem em comum encontrar falhas no artefato desenvolvido. As principais
          técnicas que podem ser aplicadas são: caixa-branca, caixa-preta e caixa-cinza. Os próximos
          tópicos detalharão cada uma dessas técnicas.

          \subsection{Técnica da caixa preta}
              É também conhecida como teste comportamental e, usualmente, é a técnica mais aplicada.
              O desenvolvedor fornece um conjunto de entradas e utiliza uma função de asserção
              para avaliar o resultado retornado, sem se preocupar com a execução interna do código.
              Essa técnica pode ser aplicada em qualquer nível de teste. Obviamente, quanto mais
              entradas sejam testadas, melhor o teste é. Como já foi dito anteriormente, é
              impossível testar todas as entradas possíveis. Nesse caso, o programador pode utilizar
              classes de equivalência para maximizar os casos de teste coberto. As classes de equivalência
              nada mais são do que dois subconjuntos do universo do conjunto de entradas possíveis
              em que um subconjunto representa as entradas válidas e o outro as entradas válidas.

              \begin{figure}[htbp]
                  \begin{center}
                      \includegraphics[width=0.7\textwidth]{img/blackbox.png}
                  \end{center}
              \caption{\label{fig:passaro}Visão da técnica da caixa preta.}
              \end{figure}

              A filosofia por trás dessa técnica, encontra-se na ideia de que basta o programador
              saber o que um determinado método deveria retornar para um certo parâmetro
              \textit{X}, ou qual atributo deveria ser atualizado. Para melhor exemplificar essa
              ideia, propõe-se mais adiante um módulo em escrito na linguagem Python capaz de fazer
              cálculo da função fatorial. Mesmo que, por um acaso, o progamador não soubesse como a
              função fatorial funcionasse ou se ainda ela fosse muito complexa envolvendo cálculos
              matemáticos avançados, basta que ele saiba que fornecendo um valor \textit{X}, o método
              deve retornar obrigatoriamente \textit{X*(X-1)*(X-2)*...*1} .

              Dessa forma, ao criar um teste para esse método basta que o programador escreva que
              quando o algoritmo for executado com o valor 4, por exemplo, deve ser retornado
              o valor 24. Caso seja retornado qualquer coisa diferente desse valor ou uma mensagem
              de erro é porque, então, existe um defeito no módulo implementado. É claro que a
              a função de cálculo de fatorial é um algoritmo trivial de ser testado. Porém, em
              projetos mais complexos de software há a necessidade de se explicitar o que cada
              método deve retornar a fim de que quem escrever um teste baseado na técnica da caixa
              preta possa fazê-lo sem saber como o método é realmente implementado.

              \begin{figure}[!htbp]
                  \begin{lstlisting}
                      class FactorialCalculator(object):
                        def __init__(self):
                          pass

                        def factorial(n):
                          result = 1
                          while (n != 0):
                            result *= n
                            n -= 1
                          return result

                  \end{lstlisting}
                  \caption{\label{fig:passaro}Módulo com implementação de método que calcula fatorial}
              \end{figure}

              Usualmente, nesse tipo de técnica, costuma-se buscar valores limites de para verificar
              se o módulo está se comportando como deveria, uma vez que os defeitos de um software
              costumam ficar em suas frestas (WAZLAWICK, 2012). Considerando que o método recebe somente
              valores inteiros, o algoritmo possui uma grande falha no que se refere as frestas. Ele, apesar de
              calcular corretamente os valores para qualquer inteiro não negativo, se eventualmente o método
              for executado usando como parâmetro um inteiro negativo, então o módulo ficará computando até o
              processo ser morto, eventualmente.

              Aplicando o princípio dos conjuntos de equivalência para um possível arquivo de teste
              para este módulo, o desenvolvedor poderia criar testes usando os seguintes valores como
              parâmetro: -2, -1, 0, 1 e 2. Para os valores negativos, o programa, necessariamente deveria
              lançar uma exceção e o teste, ao receber a exceção, deveria afirmar que tudo ocorreu como
              esperado. Nesse caso, para arrumar o módulo implementado, ao em vez de usar o
              operador de diferença, basta utilizar o operado de >. Para os demais valores, basta criar os
              casos de teste utilizando a técnica da caixa preta como foi descrita anteriormente.

          \subsection{Técnica da caixa branca}
              A técnica da caixa branca, por sua vez, é uma técnica muito mais robusta que se comparada a da
              caixa preta. A ideia consiste em testar qual fluxo o código está sendo executado no componente.
              Esse tipo de teste visa eliminiar trechos que nunca são alcançados dentro de um método ou que
              sejam reduntantes. Quando esta técnica é aplicada todas as possibilidades de fluxo um método
              devem ser testados (i.e. \textit{while, for, if, else, try, catch, finally}).

              Esse tipo de teste não necessariamente procura erros dentro de um módulo, mas busca otimizá-lo,
              em termos de processamento. Isso decorre do fato de que, podem haver estruturas de controle de
              fluxo que estão sendo declaradas, mas nunca são alcançadas. Ou seja, o módulo está funcionando
              corretamente, justamente por tais estruturas não estarem sendo executas. Dessa forma, a finalidade
              do teste é diminuir as linhas de código e deixar ele com um desempenho ainda maior.

              Nessa subsecção, cabe um comentário para complementar o que foi apresentado quanto a questão de
              modelagem de testes baseado em autômatos. Conforme Wazlawick (2012 em p. 400) é apresentada uma
              forma de modelar testes, baseados nessa técnica, muito interessante. A ideia consiste em modelar
              um autômato finito em que que cada nodo representa uma linha ou um conjunto de linhas sequenciais
              que contenham no máximo uma estrutura de controle e as arestas representam o atendimento ou
              não da condição imposta pela estrutura. A modelagem com esse tipo autômato para o método
              de cálculo de fatorial pode ser visto na Figura 10.

              Através do diagrama, é percebido que, então, o princípio do teste é passar por todas as arestas do
              automâto e caso alguma aresta em nenhuma hipótese seja utilizada é porque a estrutura jamais
              é alcançada ou possui uma condição impossível de ser atendida.

              \begin{figure}[htbp]
                  \begin{center}
                      \includegraphics[width=1.0\textwidth]{img/whitebox.png}
                  \end{center}
              \caption{\label{fig:passaro}Visão da técnica da caixa branca usando AFD.}
              \end{figure}

              Fica evidente pela figura que quanto mais arestas o autômato possui (i.e. estruturas
              condicionais), fica mais complexo de se testar o módulo. Isso mostra a importância clara de
              que todo método deve ter no máximo 20 linhas, pois além de ser mais trivial de ser testado,
              mantém uma maior legibilidade.

          \subsection{Técnica da caixa cinza}
              Essa técnica tem por finalidade combinar as duas técnicas apresentadas anteriormente em uma
              só. A caixa cinza baseia-se em testar quais são as saídas para cada uma das entradas
              fornecidas, bem como rastrear quais foram os trechos que foram executados para gerar aquele
              resultado e avaliar se faz sentido, ou não. Utilizando o exemplo do fatorial, imaginando
              um cenário que o desenvolvedor fornece como parâmetro o valor 4 ele deveria obrigatoriamente
              retornar o valor 24. Mas, mais do que isso, a estrutura de controle \textit{while} deveria
              ser executada 4 vezes e depois retornar o valor esperado.

              Porém, em um cenário hipotético, o método poderia estar implementado de tal forma que,
              independentemente do valor fornecido como parâmetro, estaria sempre retornando o valor
              24. Isso poderia ocorrer caso o desenvolvedor estivesse com pouco tempo disponível para
              implementar a função fatorial e tivesse que priorizar outras implementações. Dessa forma,
              um teste com a caixa cinza seria a melhro técnica a ser aplicada para detectar essa falha,
              já que a técnica da caixa preta, caso estivesse sendo utilizada única e exclusivamente com
              o valor 4 jamais detectaria que o módulo possui um problema. Com a caixa branca combinada
              (i.e. a caixa cinza em si), o teste apontaria que apesar de o valor retornado ser o esperado,
              o método while não foi exeuctado o número de veazes esperado.

  % ---
  \chapter{Desenvolvimento Mobile}
  % ---

  % ----------------------------------------------------------
  % Resultados
  % ----------------------------------------------------------
  \part{Trabalhos relacionados}

  % ---
  % primeiro capitulo de Resultados
  % ---
  \chapter{Trabalho 1}

  \chapter{Trabalho 2}

  \chapter{Trabalho 3}

  \part{Implementação da solução}

  \chapter{Modelagem UML}

  \chapter{Implementação}

  \chapter{Testando o Framework}

  \part{Resultados e trabalhos futuros}

  \chapter{Resultados obtidos}

  \chapter{Sugestões de trabalhos futuros}

  \chapter{Conclusão}



  % ---
  % Finaliza a parte no bookmark do PDF, para que se inicie o bookmark na raiz
  % ---
  \bookmarksetup{startatroot}%
  % ---

  % ---
  % Conclusão
  % ---

  \lipsum[31-33]

  % ----------------------------------------------------------
  % ELEMENTOS PÓS-TEXTUAIS
  % ----------------------------------------------------------
  \postextual


  % ----------------------------------------------------------
  % Referências bibliográficas
  % ----------------------------------------------------------
  \bibliography{abntex2-modelo-references}
  \chapter*{Referências}
  \noindent
  WAZLAWICK, R. S. \textit{Engenharia de Software para Sistemas de Informações: Conceitos e práticas que fazem sentido}. Florianópolis [s.n.], 2012.

  \noindent
  DIJKSTRA, E. W. \textit{The Humble Programmer}. [S.I], 1971. Disponível em:
  \url{https://www.cs.utexas.edu/~EWD/transcriptions/EWD03xx/EWD340.html}.
  Acesso em 2 de Setembro de 2017.

  \noindent
  JEREMIAH, J. \textit{Is agile the new norm?}. [S.I.:s.n.], 2017 Disponível em:
  \url{https://techbeacon.com/survey-agile-new-norm}. Acesso em 2 de Setembro de 2017.

  \noindent
  KELLY, A. \textit{Programmers Without TDD Will be Unemployable by 2022}. [S.I.:s.n.],
  2014 Disponível em: \url{https://dzone.com/articles/programmers-without-tdd-will}. Acesso em 22 de Abril de 2018.

  \noindent
  ERIKSSON, U. \textit{How much time should you spend on testing?}. [S.I.:s.n.], 2014 Disponível em:
  \url{https://goo.gl/bTfQsa}. Acesso em 2 de Setembro de 2017.

  \noindent
  SILVA, Ricardo P. e, PRICE, R. T. \textit{A busca de generalidade, flexibilidade e extensibilidade no processo de desenvolvimento de frameworks orientados a objetos}. [S.I.:s.n.], 1998 Disponível em: \url{https://www.inf.ufsc.br/~ricardo.silva/publications/Ideas98.PDF}. Acesso em 4 de Março de 2018.

  \noindent
  \textit{Software design pattern}. In: Wikipédia, a enciclopédia livre. Flórida: Wikimedia Foundation,
  2018. Disponível em:
  \url{https://en.wikipedia.org/w/index.php?title=Software_design_pattern&oldid=834346932}. Accesso
  em 19 de Abril 2018.

  \noindent
  JOHNSON, R. E. \textit{Design Patterns: Abstraction and Reuse of Object-Oriented Design}. [S.I.:s.n.], 1993 Disponível em: \url{https://link-springer-com.ez46.periodicos.capes.gov.br/chapter/10.1007%2F3-540-47910-4_21}. Acesso em 26 de Março de 2018.

  \noindent
  KENT, B., ANDRES, C. \textit{Extreme Programming Explained}. [S.I.:s.n.], 2004.

  \noindent
  ERIKSSON, U. \textit{3 Reasons Why It's Important to Refactor Tests}. [S.I.:s.n.], 2016 Disponível em:
  \url{https://qualitycoding.org/why-refactor-tests/#comments}. Acesso em 4 de Maio de 2018.

  \noindent
  FOWLER, M. \textit{Making Stubs}. [S.I.:s.n.], 2003 Disponível em:
  \url{https://martinfowler.com/bliki/MakingStubs.html}. Acesso em 4 de Maio de 2018.

  \noindent
  FOWLER, M. \textit{Test Pyramid}. [S.I.:s.n.], 2012 Disponível em:
  \url{https://martinfowler.com/bliki/TestPyramid.html}. Acesso em 4 de Maio de 2018.


  % ----------------------------------------------------------
  % Glossário
  % ----------------------------------------------------------
  %
  % Consulte o manual da classe abntex2 para orientações sobre o glossário.
  %
  %\glossary

  % ----------------------------------------------------------
  % Apêndices
  % ----------------------------------------------------------

  % ---
  % Inicia os apêndices
  % ---
  \begin{apendicesenv}

  % Imprime uma página indicando o início dos apêndices
  \partapendices

  % ----------------------------------------------------------
  \chapter{Quisque libero justo}
  % ----------------------------------------------------------

  \lipsum[50]

  % ----------------------------------------------------------
  \chapter{Nullam elementum urna vel imperdiet sodales elit ipsum pharetra ligula
  ac pretium ante justo a nulla curabitur tristique arcu eu metus}
  % ----------------------------------------------------------
  \lipsum[55-57]

  \end{apendicesenv}
  % ---


  % ----------------------------------------------------------
  % Anexos
  % ----------------------------------------------------------

  % ---
  % Inicia os anexos
  % ---
  \begin{anexosenv}

  % Imprime uma página indicando o início dos anexos
  \partanexos

  % ---
  \chapter{Morbi ultrices rutrum lorem.}
  % ---
  \lipsum[30]

  % ---
  \chapter{Cras non urna sed feugiat cum sociis natoque penatibus et magnis dis
  parturient montes nascetur ridiculus mus}
  % ---

  \lipsum[31]

  % ---
  \chapter{Fusce facilisis lacinia dui}
  % ---

  \lipsum[32]

  \end{anexosenv}

  %---------------------------------------------------------------------
  % INDICE REMISSIVO
  %---------------------------------------------------------------------

  \printindex

  \end{document}
